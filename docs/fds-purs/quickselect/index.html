<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="generator" content="Astro v2.5.6">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

<!-- Canonical URL -->
<link rel="canonical" href="https://example.com/fds-purs/quickselect/">

<!-- Primary Meta Tags -->
<title>Functional Data Structure</title>
<meta name="title" content="Functional Data Structure">
<meta name="description" content="&#34;A comprehensive tutorial on functional data structures implemented using Purescript&#34;">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://example.com/fds-purs/quickselect/">
<meta property="og:title" content="Functional Data Structure">
<meta property="og:description" content="&#34;A comprehensive tutorial on functional data structures implemented using Purescript&#34;">
<meta property="og:image" content="https://example.com/placeholder-social.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://example.com/fds-purs/quickselect/">
<meta property="twitter:title" content="Functional Data Structure">
<meta property="twitter:description" content="&#34;A comprehensive tutorial on functional data structures implemented using Purescript&#34;">
<meta property="twitter:image" content="https://example.com/placeholder-social.jpg">
	<link rel="stylesheet" href="/_astro/index.74a074fc.css" /></head>
	<body>
		<div class="navbar">
<a class="navbar-brand" href="/" aria-current="page">
	<h1>Functional Data Structure</h1>
</a>
</div>
		<br>
		<br>
        <main>
            <div class="lesson-container">
				<div class="lesson">
					<h1 id="quickselect-algorithm">QuickSelect Algorithm</h1>
<p>The QuickSelect algorithm is a very efficient method to find the k-th smallest (or largest) element in an unordered list. It was developed by Tony Hoare, who also created the QuickSort algorithm. It’s a “selection” algorithm, meaning it’s used for selecting a specific item from a data structure.</p>
<h2 id="basic-idea">Basic Idea</h2>
<p>QuickSelect uses a “divide and conquer” strategy similar to QuickSort. It starts by choosing a “pivot” from the list. The list is then partitioned into two sub-lists, one with elements less than the pivot and one with elements greater than the pivot. This is done in linear time using the Lomuto or Hoare partitioning scheme.</p>
<p>However, unlike QuickSort, which recursively processes both sub-lists, QuickSelect only processes the sub-list that the k-th element is in. This is what gives QuickSelect its average time complexity of O(n), making it faster than sorting the list and picking the k-th element (which would take O(n log n) time).</p>
<h2 id="the-algorithm">The Algorithm</h2>
<p>Here is a simplified implementation of QuickSelect in Purescript:</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #F97583">module</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">QuickSelect</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">where</span></span>
<span class="line"></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Prelude</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Data.List</span><span style="color: #E1E4E8"> (</span><span style="color: #B392F0">List(..)</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">filter</span><span style="color: #E1E4E8">, </span><span style="color: #B392F0">length</span><span style="color: #E1E4E8">)</span></span>
<span class="line"><span style="color: #F97583">import</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">Data.Maybe</span><span style="color: #E1E4E8"> (</span><span style="color: #B392F0">Maybe(..)</span><span style="color: #E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #B392F0">quickselect</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">::</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">forall</span><span style="color: #E1E4E8"> a. </span><span style="color: #B392F0">Ord</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">=></span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">List</span><span style="color: #E1E4E8"> a </span><span style="color: #F97583">-></span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Int</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">-></span><span style="color: #E1E4E8"> </span><span style="color: #B392F0">Maybe</span><span style="color: #E1E4E8"> a</span></span>
<span class="line"><span style="color: #E1E4E8">quickselect </span><span style="color: #85E89D">Nil</span><span style="color: #E1E4E8"> _ </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> </span><span style="color: #85E89D">Nothing</span></span>
<span class="line"><span style="color: #E1E4E8">quickselect (x </span><span style="color: #F97583">:</span><span style="color: #E1E4E8"> xs) k </span><span style="color: #F97583">=</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">let</span></span>
<span class="line"><span style="color: #E1E4E8">    xs1 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> filter (_ </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> x) xs</span></span>
<span class="line"><span style="color: #E1E4E8">    xs2 </span><span style="color: #F97583">=</span><span style="color: #E1E4E8"> filter (_ </span><span style="color: #F97583">>=</span><span style="color: #E1E4E8"> x) xs</span></span>
<span class="line"><span style="color: #E1E4E8">  </span><span style="color: #F97583">in</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> k </span><span style="color: #F97583">&#x3C;</span><span style="color: #E1E4E8"> length xs1 </span><span style="color: #F97583">then</span><span style="color: #E1E4E8"> quickselect xs1 k</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> </span><span style="color: #F97583">if</span><span style="color: #E1E4E8"> k </span><span style="color: #F97583">==</span><span style="color: #E1E4E8"> length xs1 </span><span style="color: #F97583">then</span><span style="color: #E1E4E8"> </span><span style="color: #85E89D">Just</span><span style="color: #E1E4E8"> x</span></span>
<span class="line"><span style="color: #E1E4E8">    </span><span style="color: #F97583">else</span><span style="color: #E1E4E8"> quickselect xs2 (k </span><span style="color: #F97583">-</span><span style="color: #E1E4E8"> length xs1 </span><span style="color: #F97583">-</span><span style="color: #E1E4E8"> </span><span style="color: #79B8FF">1</span><span style="color: #E1E4E8">)</span></span></code></pre>
<p>This version of QuickSelect uses the “list comprehension” feature in Python to create the left, middle, and right lists. It assumes a function <code>selectPivot</code> is available to choose a pivot from the list.</p>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The average time complexity of QuickSelect is O(n), but its worst-case time complexity is O(n^2). The worst-case scenario occurs when the pivot chosen is the smallest or largest element in the list, leading to very unbalanced partitions.</p>
<p>Many methods exist to select a “good” pivot, such as choosing the median of the list, choosing a random element, or using the “median of medians” algorithm. A good pivot is one that gives roughly equal-sized partitions, which is what gives QuickSelect its average-case time complexity of O(n).</p>
<p>The space complexity of QuickSelect is O(n) because it needs to create new lists for each recursive call. However, this can be reduced to O(1) by doing the partitioning in-place (i.e., modifying the original list).</p>
<h2 id="usage">Usage</h2>
<p>QuickSelect is often used in scenarios where only a specific element of a list is needed, rather than the entire sorted list. Examples include finding the median of a list, finding the most common element (mode), or finding the element with a certain rank in a list of scores. It’s also used as a building block in other algorithms, such as QuickSort.</p>
<p>In conclusion, QuickSelect is a powerful algorithm that can be very efficient for certain selection tasks. Its average-case efficiency, combined with its relative simplicity, makes it a valuable tool for any programmer’s toolkit.</p>
				</div>
				
			</div>
        </main>
        <footer class="astro-SZ7XMLTE">
	&copy; 2022 - 2023 Tao Xiang. All rights reserved.
</footer>
	</body></html>