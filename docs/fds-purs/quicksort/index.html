<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- Global Metadata --><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="icon" type="image/svg+xml" href="/favicon.svg">
<meta name="generator" content="Astro v2.5.6">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

<!-- Canonical URL -->
<link rel="canonical" href="https://example.com/fds-purs/quicksort/">

<!-- Primary Meta Tags -->
<title>Functional Data Structure</title>
<meta name="title" content="Functional Data Structure">
<meta name="description" content="Welcome to my website!">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://example.com/fds-purs/quicksort/">
<meta property="og:title" content="Functional Data Structure">
<meta property="og:description" content="Welcome to my website!">
<meta property="og:image" content="https://example.com/placeholder-social.jpg">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://example.com/fds-purs/quicksort/">
<meta property="twitter:title" content="Functional Data Structure">
<meta property="twitter:description" content="Welcome to my website!">
<meta property="twitter:image" content="https://example.com/placeholder-social.jpg">
	<link rel="stylesheet" href="/_astro/index.dbe3beaf.css" /></head>
	<body>
		<div class="navbar">
<a class="navbar-brand" href="/" aria-current="page">
	<h1>Functional Data Structure</h1>
</a>
</div>
		<br>
		<br>
        <main>
            <div class="lesson-container">
				<div class="lesson">
					<h1 id="quicksort-algorithm">QuickSort Algorithm</h1>
<p>The QuickSort algorithm is a popular and efficient sorting algorithm invented by British computer scientist Tony Hoare in 1960. QuickSort utilizes a “divide and conquer” strategy, making it a comparison sort like MergeSort and HeapSort. It’s often favored due to its efficiency and ease of implementation.</p>
<h2 id="basic-idea">Basic Idea</h2>
<p>QuickSort works by selecting a ‘pivot’ element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.</p>
<h2 id="the-algorithm">The Algorithm</h2>
<p>Here’s a simplified implementation of QuickSort in Purescript:</p>
<pre is:raw="" class="astro-code github-dark" style="background-color: #24292e; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color: #e1e4e8">quicksort :: forall a. Ord a => List a -> List a</span></span>
<span class="line"><span style="color: #e1e4e8">quicksort Nil = Nil</span></span>
<span class="line"><span style="color: #e1e4e8">quicksort (x:xs) = </span></span>
<span class="line"><span style="color: #e1e4e8">   let </span></span>
<span class="line"><span style="color: #e1e4e8">      pivot = fromMaybe x (xs !! (length xs `div` 2))</span></span>
<span class="line"><span style="color: #e1e4e8">      left = filter (_ &#x3C; pivot) (x:xs)</span></span>
<span class="line"><span style="color: #e1e4e8">      middle = filter (_ == pivot) (x:xs)</span></span>
<span class="line"><span style="color: #e1e4e8">      right = filter (_ > pivot) (x:xs)</span></span>
<span class="line"><span style="color: #e1e4e8">    in</span></span>
<span class="line"><span style="color: #e1e4e8">         quicksort left &#x3C;> middle &#x3C;> quicksort right</span></span></code></pre>
<p>This version of QuickSort uses the “list comprehension” feature in Python to create the left, middle, and right arrays. It uses the middle element as the pivot.</p>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>The best case and average case time complexity of QuickSort is O(n log n), but its worst-case time complexity is O(n^2). The worst-case scenario occurs when the smallest or largest element is always chosen as the pivot, leading to highly unbalanced partitions.</p>
<p>However, this worst-case scenario isn’t common if the pivot is chosen wisely. Many strategies exist to choose a “good” pivot, such as randomly selecting an element, choosing the median, or using the “median of medians” algorithm. A good pivot is one that gives roughly balanced partitions, which is what gives QuickSort its average-case time complexity of O(n log n).</p>
<p>The space complexity of QuickSort is O(log n) due to the stack space required for recursion, assuming a good pivot selection strategy that guarantees balanced splits.</p>
<h2 id="usage">Usage</h2>
<p>QuickSort is a versatile and efficient algorithm used in a variety of applications. It excels when used on in-memory data and can be parallelized due to its divide-and-conquer nature. QuickSort is also an in-place sorting algorithm, requiring only a small, constant amount of auxiliary storage.</p>
<p>However, QuickSort can perform poorly for certain types of data, such as when the input array is already sorted or nearly sorted. It’s also not stable, meaning that equal elements may not maintain their original order in the sorted output.</p>
<p>Despite these limitations, QuickSort is a powerful sorting algorithm with wide applications due to its average-case efficiency, in-place sorting capability, and ease of implementation. It’s a valuable addition to any programmer’s toolkit.</p>
<p>In conclusion, QuickSort is a highly efficient and versatile sorting algorithm with wide application. Its main strengths lie in its average-case efficiency, in-place sorting capability, and the ease with which it can be implemented.</p>
				</div>
				
			</div>
        </main>
        <footer class="astro-SZ7XMLTE">
	&copy; 2022 - 2023 Tao Xiang. All rights reserved.
</footer>
	</body></html>